## 15.4 Bảo mật Actuator

Thông tin được trình bày bởi Actuator có lẽ không phải là thứ mà bạn muốn những con mắt tò mò nhìn thấy. Hơn nữa, vì Actuator cung cấp một vài thao tác cho phép bạn thay đổi các thuộc tính môi trường và cấp độ logging, nên việc bảo mật Actuator để chỉ những client có quyền truy cập thích hợp mới có thể sử dụng các endpoint của nó là một ý tưởng hay.

Mặc dù việc bảo mật Actuator là quan trọng, nhưng bảo mật không nằm trong phạm vi trách nhiệm của Actuator. Thay vào đó, bạn sẽ cần sử dụng Spring Security để bảo vệ Actuator. Và vì các endpoint của Actuator chỉ là các đường dẫn trong ứng dụng như bất kỳ đường dẫn nào khác, nên không có gì đặc biệt khi bảo mật Actuator so với các đường dẫn ứng dụng khác. Mọi thứ chúng ta đã thảo luận trong chương 5 đều áp dụng khi bảo mật các endpoint của Actuator.

Bởi vì tất cả các endpoint của Actuator được gom lại dưới một đường dẫn cơ sở chung là /actuator (hoặc có thể là một đường dẫn cơ sở khác nếu thuộc tính `management.endpoints.web.base-path` được thiết lập), nên việc áp dụng các quy tắc phân quyền cho tất cả các endpoint của Actuator là khá dễ dàng. Ví dụ, để yêu cầu người dùng phải có quyền `ROLE_ADMIN` để gọi các endpoint của Actuator, bạn có thể override phương thức `configure()` của `WebSecurityConfigurerAdapter` như sau:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .authorizeRequests()
    .antMatchers("/actuator/**").hasRole("ADMIN")
    .and()
    .httpBasic();
}
```

Việc này yêu cầu tất cả các request phải đến từ một người dùng đã xác thực có quyền `ROLE_ADMIN`. Nó cũng cấu hình xác thực HTTP basic để các ứng dụng client có thể gửi thông tin xác thực đã được mã hóa trong header `Authorization` của request.

Vấn đề thực sự duy nhất với cách bảo mật Actuator này là đường dẫn đến các endpoint bị mã hóa cứng là /actuator/\*\*. Nếu điều này thay đổi do thay đổi thuộc tính `management.endpoints.web.base-path`, thì nó sẽ không còn hoạt động nữa. Để hỗ trợ điều này, Spring Boot cũng cung cấp `EndpointRequest` — một lớp request matcher giúp việc này dễ dàng hơn và ít phụ thuộc vào một chuỗi `String` cụ thể. Sử dụng `EndpointRequest`, bạn có thể áp dụng các yêu cầu bảo mật tương tự cho các endpoint của Actuator mà không cần mã hóa cứng đường dẫn /actuator/**, như minh họa sau:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .requestMatcher(EndpointRequest.toAnyEndpoint())
      .authorizeRequests()
        .anyRequest().hasRole("ADMIN")
    .and()
    .httpBasic();
}
```

Phương thức `EndpointRequest.toAnyEndpoint()` trả về một request matcher khớp với bất kỳ endpoint nào của Actuator. Nếu bạn muốn loại trừ một số endpoint khỏi request matcher, bạn có thể gọi `excluding()` và chỉ định chúng theo tên như sau:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .requestMatcher(EndpointRequest.toAnyEndpoint().excluding("health", "info"))
    .authorizeRequests()
      .anyRequest().hasRole("ADMIN")
    .and()
    .httpBasic();
}
```

Mặt khác, nếu bạn chỉ muốn áp dụng bảo mật cho một vài endpoint của Actuator, bạn có thể chỉ định các endpoint đó theo tên bằng cách gọi `to()` thay vì `toAnyEndpoint()`, như sau:

```java
@Override
protected void configure(HttpSecurity http) throws Exception {
  http
    .requestMatcher(EndpointRequest.to("beans", "threaddump", "loggers"))
    .authorizeRequests()
    .anyRequest().hasRole("ADMIN")
    .and()
    .httpBasic();
}
```

Việc này giới hạn bảo mật Actuator chỉ đối với các endpoint /beans, /threaddump và /loggers. Tất cả các endpoint Actuator khác sẽ được để mở hoàn toàn.
