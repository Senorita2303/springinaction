### 13.2.2 Định nghĩa các repository MongoDB phản ứng

Bây giờ chúng ta sẽ cần định nghĩa hai repository, một cho root tổng hợp `TacoOrder` và một cho `Ingredient`. Chúng ta sẽ không cần repository cho `Taco` vì nó là con của root `TacoOrder`.

Giao diện `IngredientRepository`, được hiển thị dưới đây, chắc hẳn bạn đã quen thuộc:

```java
package tacos.data;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;
import org.springframework.web.bind.annotation.CrossOrigin;

import tacos.Ingredient;

@CrossOrigin(origins="*")
public interface IngredientRepository
      extends ReactiveCrudRepository<Ingredient, String> {
}
```

Giao diện `IngredientRepository` này chỉ hơi khác một chút so với cái mà chúng ta đã định nghĩa trong chương 4, đó là nó kế thừa `ReactiveCrudRepository` thay vì `CrudRepository`. Và nó cũng khác với cái chúng ta tạo ra cho cơ chế lưu trữ Spring Data R2DBC ở chỗ nó không bao gồm phương thức `findBySlug()`.

Tương tự, `OrderRepository` gần như giống hệt với repository MongoDB mà chúng ta đã tạo trong chương 4, được hiển thị tiếp theo:

```java
package tacos.data;

import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;

import reactor.core.publisher.Flux;
import tacos.TacoOrder;
import tacos.User;

public interface OrderRepository
      extends ReactiveCrudRepository<TacoOrder, String> {

  Flux<TacoOrder> findByUserOrderByPlacedAtDesc(
      User user, Pageable pageable);

}

```

Cuối cùng, sự khác biệt duy nhất giữa các repository MongoDB phản ứng và không phản ứng là liệu chúng kế thừa `ReactiveCrudRepository` hay `CrudRepository`. Tuy nhiên, khi chọn kế thừa `ReactiveCrudRepository`, các client của những repository này phải chuẩn bị để làm việc với các kiểu phản ứng như `Flux` và `Mono`. Điều đó sẽ trở nên rõ ràng khi chúng ta viết các bài kiểm thử cho các repository phản ứng, đó là điều chúng ta sẽ làm tiếp theo.
