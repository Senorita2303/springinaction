### 13.2.1 Định nghĩa các kiểu tài liệu miền (domain document types)

Như trước đây, chúng ta sẽ cần tạo các lớp định nghĩa miền (domain) của ứng dụng. Khi làm điều đó, chúng ta cần chú thích chúng bằng chú thích `@Document` của Spring Data MongoDB, giống như chúng ta đã làm trong chương 4, để chỉ ra rằng chúng là các tài liệu sẽ được lưu trữ trong MongoDB. Hãy bắt đầu với lớp `Ingredient`, được hiển thị dưới đây.

**Listing 13.12 Một lớp Ingredient được chú thích để lưu trữ với Mongo**

```java
package tacos;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)
@Document
public class Ingredient {

  @Id
  private String id;
  private String name;
  private Type type;

  public static enum Type {
    WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
  }

}
```

Một người tinh ý sẽ nhận thấy rằng lớp `Ingredient` này giống hệt với lớp mà chúng ta đã tạo trong chương 4. Thật vậy, các lớp `@Document` của MongoDB đều giống nhau bất kể được lưu trữ qua repository phản ứng hay không phản ứng. Điều đó có nghĩa là các lớp `Taco` và `TacoOrder` sẽ giống với các lớp mà chúng ta đã tạo trong chương 4. Nhưng để đầy đủ — và để bạn không cần phải quay lại chương 4 — chúng tôi sẽ lặp lại chúng ở đây.

Một lớp Taco được chú thích tương tự được hiển thị tiếp theo.

**Listing 13.13 Một lớp Taco được chú thích để lưu trữ với Mongo**

```java
package tacos;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;
import org.springframework.data.rest.core.annotation.RestResource;

import lombok.Data;

@Data
@RestResource(rel = "tacos", path = "tacos")
@Document
public class Taco {

  @Id
  private String id;

  @NotNull
  @Size(min = 5, message = "Name must be at least 5 characters long")
  private String name;

  private Date createdAt = new Date();

  @Size(min=1, message="You must choose at least 1 ingredient")
  private List<Ingredient> ingredients = new ArrayList<>();

  public void addIngredient(Ingredient ingredient) {
    this.ingredients.add(ingredient);
  }
}

```

Lưu ý rằng, không giống như `Ingredient`, lớp `Taco` không được chú thích với `@Document`. Đó là vì nó không được lưu dưới dạng một tài liệu riêng biệt mà được lưu như một phần của root tổng hợp `TacoOrder`. Mặt khác, vì `TacoOrder` là một root tổng hợp nên nó được chú thích với `@Document` như được hiển thị trong đoạn mã tiếp theo.

**Listing 13.14 Một lớp TacoOrder được chú thích để lưu trữ với Mongo**

```java
package tacos;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import org.springframework.data.annotation.Id;
import org.springframework.data.mongodb.core.mapping.Document;

import lombok.Data;

@Data
@Document
public class TacoOrder implements Serializable {
  private static final long serialVersionUID = 1L;

  @Id
  private String id;
  private Date placedAt = new Date();

  private User user;

  private String deliveryName;

  private String deliveryStreet;

  private String deliveryCity;

  private String deliveryState;

  private String deliveryZip;

  private String ccNumber;

  private String ccExpiration;

  private String ccCVV;

  private List<Taco> tacos = new ArrayList<>();

  public void addTaco(Taco taco) {
    this.tacos.add(taco);
  }
}
```

Một lần nữa, các lớp tài liệu miền không có gì khác biệt khi dùng với repository MongoDB phản ứng so với các repository không phản ứng. Như bạn sẽ thấy tiếp theo, chính các repository MongoDB phản ứng cũng chỉ khác một chút rất nhỏ so với các đối tác không phản ứng của chúng.
