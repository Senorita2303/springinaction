### 13.2.2 Tạo các repository Cassandra phản ứng

Tới thời điểm này, có thể bạn đã đoán được rằng các repository Cassandra phản ứng trông rất giống với các repository không phản ứng tương đương. Nếu đúng vậy thì tuyệt! Bạn đang dần hiểu rằng Spring Data, bất cứ khi nào có thể, đều cố gắng duy trì một mô hình lập trình tương tự, bất kể repository đó có phải là phản ứng hay không.

Bạn có thể đã đoán ra rằng điểm khác biệt chính duy nhất khiến các repository trở thành phản ứng là việc các interface mở rộng từ `ReactiveCrudRepository`, như được thể hiện trong interface `IngredientRepository`:  

```java
package tacos.data;

import org.springframework.data.repository.reactive.ReactiveCrudRepository;

import tacos.Ingredient;

public interface IngredientRepository
      extends ReactiveCrudRepository<Ingredient, String> {
}
```

Tất nhiên, điều tương tự cũng đúng với `OrderRepository`, như được hiển thị tiếp theo:

```java
package tacos.data;

import java.util.UUID;

import org.springframework.data.domain.Pageable;
import org.springframework.data.repository.reactive.ReactiveCrudRepository;

import reactor.core.publisher.Flux;
import tacos.TacoOrder;
import tacos.User;

public interface OrderRepository
      extends ReactiveCrudRepository<TacoOrder, UUID> {

  Flux<TacoOrder> findByUserOrderByPlacedAtDesc(
      User user, Pageable pageable);
}
```

Thực tế, không chỉ các repository này gợi nhớ đến các phiên bản không phản ứng của chúng, mà chúng cũng không khác nhiều so với các repository MongoDB mà chúng ta đã viết trước đó trong chương này. Ngoài việc Cassandra sử dụng `UUID` làm kiểu ID thay vì `String` cho `TacoOrder`, chúng gần như giống hệt nhau. Điều này một lần nữa cho thấy tính nhất quán được áp dụng (nếu có thể) trong các dự án của Spring Data.

Hãy kết thúc phần tìm hiểu về cách viết các repository Cassandra phản ứng bằng cách viết một vài bài kiểm thử để xác minh rằng chúng hoạt động đúng.
