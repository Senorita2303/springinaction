### 13.2.1 Định nghĩa các lớp miền cho việc lưu trữ Cassandra

Cũng giống như khi lưu trữ với Mongo, việc lựa chọn giữa Cassandra phản ứng (reactive) và không phản ứng (nonreactive) hoàn toàn không ảnh hưởng gì đến cách bạn định nghĩa các lớp miền. Các lớp miền cho `Ingredient`, `Taco` và `TacoOrder` mà chúng ta sẽ sử dụng giống hệt với những gì đã được tạo ra trong chương 4. Một lớp `Ingredient` được chú thích để lưu trữ trong Cassandra được hiển thị dưới đây.

**Danh sách 13.17 Chú thích lớp Ingredient để lưu trữ trong Cassandra**  

```java
package tacos;

import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(access=AccessLevel.PRIVATE, force=true)
@Table("ingredients")
public class Ingredient {

  @PrimaryKey
  private String id;
  private String name;
  private Type type;

  public static enum Type {
    WRAP, PROTEIN, VEGGIES, CHEESE, SAUCE
  }

}
```

Đối với lớp `Taco`, nó cũng được định nghĩa với các chú thích Cassandra tương tự trong đoạn mã tiếp theo.

**Danh sách 13.18 Chú thích lớp Taco để lưu trữ trong Cassandra**

```java
package tacos;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

import org.springframework.data.cassandra.core.cql.Ordering;
import org.springframework.data.cassandra.core.cql.PrimaryKeyType;
import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKeyColumn;
import org.springframework.data.cassandra.core.mapping.Table;
import org.springframework.data.rest.core.annotation.RestResource;

import com.datastax.oss.driver.api.core.uuid.Uuids;

import lombok.Data;

@Data
@RestResource(rel = "tacos", path = "tacos")
@Table("tacos")
public class Taco {

  @PrimaryKeyColumn(type=PrimaryKeyType.PARTITIONED)
  private UUID id = Uuids.timeBased();

  @NotNull
  @Size(min = 5, message = "Name must be at least 5 characters long")
  private String name;

  @PrimaryKeyColumn(type=PrimaryKeyType.CLUSTERED,
          ordering=Ordering.DESCENDING)
  private Date createdAt = new Date();

  @Size(min=1, message="You must choose at least 1 ingredient")
  @Column("ingredients")
  private List<IngredientUDT> ingredients = new ArrayList<>();

  public void addIngredient(Ingredient ingredient) {
    this.ingredients.add(new IngredientUDT(ingredient.getName(), ingredient.getType()));
  }
}
```

Vì `Taco` tham chiếu đến các đối tượng `Ingredient` thông qua một kiểu do người dùng định nghĩa (user-defined type), bạn cũng sẽ cần có lớp `IngredientUDT`, như được hiển thị dưới đây.

**Danh sách 13.19 Kiểu do người dùng định nghĩa Ingredient cho Cassandra**

```java
package tacos;

import org.springframework.data.cassandra.core.mapping.UserDefinedType;

import lombok.AccessLevel;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor(access = AccessLevel.PRIVATE, force = true)
@UserDefinedType("ingredient")
public class IngredientUDT {
  private String name;
  private Ingredient.Type type;
}
```

Lớp cuối cùng trong ba lớp miền của chúng ta, `TacoOrder`, được chú thích để lưu trữ trong Cassandra như trong đoạn mã sau.

**Danh sách 13.20 Chú thích lớp TacoOrder để lưu trữ trong Cassandra**

```java
package tacos;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.UUID;

import org.springframework.data.cassandra.core.mapping.Column;
import org.springframework.data.cassandra.core.mapping.PrimaryKey;
import org.springframework.data.cassandra.core.mapping.Table;

import com.datastax.oss.driver.api.core.uuid.Uuids;

import lombok.Data;

@Data
@Table("tacoorders")
public class TacoOrder implements Serializable {
  private static final long serialVersionUID = 1L;

  @PrimaryKey
  private UUID id = Uuids.timeBased();
  private Date placedAt = new Date();

  @Column("user")
  private UserUDT user;

  private String deliveryName;

  private String deliveryStreet;

  private String deliveryCity;

  private String deliveryState;

  private String deliveryZip;

  private String ccNumber;

  private String ccExpiration;

  private String ccCVV;

  @Column("tacos")
  private List<TacoUDT> tacos = new ArrayList<>();

  public void addTaco(Taco taco) {
    this.addTaco(new TacoUDT(taco.getName(), taco.getIngredients()));
  }
  public void addTaco(TacoUDT tacoUDT) {
    this.tacos.add(tacoUDT);
  }
}
```

Và, giống như `Taco` tham chiếu đến `Ingredient` thông qua một kiểu do người dùng định nghĩa, `TacoOrder` cũng tham chiếu đến `Taco` thông qua lớp `TacoUDT`, được hiển thị tiếp theo.

**Danh sách 13.21 Kiểu do người dùng định nghĩa Taco cho Cassandra**

```java
package tacos;

import java.util.List;

import org.springframework.data.cassandra.core.mapping.UserDefinedType;

import lombok.Data;

@Data
@UserDefinedType("taco")
public class TacoUDT {

  private final String name;
  private final List<IngredientUDT> ingredients;

}
```

Cần nhấn mạnh lại rằng những lớp này giống hệt với các phiên bản không phản ứng của chúng. Tôi chỉ nhắc lại chúng ở đây để bạn không phải lật lại 11 chương trước để nhớ chúng trông như thế nào.

Bây giờ hãy định nghĩa các repository để lưu trữ các đối tượng này.
